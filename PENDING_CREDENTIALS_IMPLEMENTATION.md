# Реализация автоматической отложенной отправки учетных данных

## Проблема

При одобрении пользователя через веб-интерфейс система пытается отправить email с учетными данными. Однако на бесплатном тарифе Unisender можно отправлять письма только на **подтвержденные** email адреса. Если пользователь еще не подтвердил свой email, отправка не удается.

## Решение

Реализован механизм **автоматической отложенной отправки учетных данных** после подтверждения email пользователем.

## Как это работает

### 1. При одобрении пользователя

Когда администратор одобряет заявку пользователя:

1. Система генерирует логин и пароль
2. Пытается отправить email с учетными данными
3. **Если email не подтвержден:**
   - Устанавливается флаг `pending_credentials_email = True`
   - Пароль временно сохраняется в поле `pending_password_plain`
   - Учетные данные будут отправлены автоматически после подтверждения

### 2. Периодическая проверка

Функция `send_pending_credentials_emails()` автоматически вызывается при ежедневных задачах и:

1. Находит всех пользователей с `pending_credentials_email = True`
2. Пытается отправить учетные данные каждому пользователю
3. **Если email подтвержден:**
   - Отправляет письмо с учетными данными
   - Снимает флаг `pending_credentials_email`
   - Очищает поле `pending_password_plain`
4. **Если email еще не подтвержден:**
   - Оставляет флаг для следующей проверки
   - Увеличивает счетчик попыток

### 3. Ограничения безопасности

- Максимум **10 попыток** отправки на пользователя
- После достижения лимита флаг автоматически снимается
- Пароль хранится временно и очищается после отправки

## Установка

### 1. Выполните миграцию базы данных

```sql
-- Файл: backend/migrations/002_add_pending_credentials_fields.sql
-- Добавляет поля:
-- - pending_credentials_email (BOOLEAN)
-- - credentials_email_sent_at (TIMESTAMP)
-- - credentials_email_attempts (INTEGER)
-- - pending_password_plain (VARCHAR)
```

### 2. Настройка Unisender

В файле `.env` установите:

```env
# Для отправки письма подтверждения пользователю
UNISENDER_DOUBLE_OPTIN=1

# Или для добавления без письма (но на бесплатном тарифе все равно требуется подтверждение)
UNISENDER_DOUBLE_OPTIN=3
```

### 3. Настройка планировщика

Функция автоматически вызывается при ежедневных задачах. Убедитесь, что cron настроен:

```bash
# Ежедневно в 00:00 UTC
0 0 * * * curl -X POST https://your-api.com/scheduler/run-daily-tasks \
  -H "X-Cron-Secret: your_admin_api_key"
```

## API Endpoints

### Автоматический вызов (рекомендуется)

Функция вызывается автоматически при ежедневных задачах:
```
POST /scheduler/run-daily-tasks
Headers: X-Cron-Secret: your_admin_api_key
```

### Ручной вызов

Можно вызвать отдельно для проверки отложенных учетных данных:
```
POST /scheduler/send-pending-credentials
Headers: X-Cron-Secret: your_admin_api_key
```

**Ответ:**
```json
{
  "status": "ok",
  "total_checked": 5,
  "emails_sent": 2,
  "still_pending": 3,
  "errors": []
}
```

## Мониторинг

### Логирование

Система логирует все действия:

- Установка флага отложенной отправки
- Попытки отправки учетных данных
- Успешные отправки
- Ошибки и достижение лимита попыток

### Проверка статуса

Для проверки пользователей с отложенными учетными данными:

```sql
SELECT 
    id, 
    email, 
    login,
    pending_credentials_email,
    credentials_email_attempts,
    credentials_email_sent_at
FROM users 
WHERE pending_credentials_email = TRUE;
```

## Безопасность

### Хранение паролей

- Пароль временно сохраняется в поле `pending_password_plain` в открытом виде
- После успешной отправки поле очищается (`NULL`)
- Пароль также очищается при снятии флага `pending_credentials_email`
- Максимальное время хранения: до 10 попыток отправки (обычно несколько дней)

### Рекомендации

1. **Регулярно проверяйте** пользователей с `pending_credentials_email = TRUE`
2. **Ограничьте доступ** к полю `pending_password_plain` в базе данных
3. **Мониторьте логи** на предмет ошибок отправки
4. **Рассмотрите переход** на платный тариф Unisender или альтернативный сервис для лучшей доставляемости

## Альтернативные решения

Если автоматическая отправка не подходит, можно:

1. **Отправлять учетные данные через Telegram** - если у пользователя есть Telegram ID
2. **Использовать платный тариф Unisender** - нет ограничений на подтверждение
3. **Перейти на альтернативный сервис** - см. `UNISENDER_EMAIL_SOLUTIONS.md`

## Примеры использования

### Проверка статуса пользователя

```python
from crud import get_user_by_id
from database import get_db

async def check_user_status(user_id: int):
    async for db in get_db():
        user = await get_user_by_id(db, user_id)
        if user.pending_credentials_email:
            print(f"Учетные данные ожидают отправки. Попыток: {user.credentials_email_attempts}")
        else:
            print("Учетные данные отправлены или не требуют отправки")
```

### Ручная отправка для конкретного пользователя

```python
from crud import send_pending_credentials_emails
from database import get_db

async def send_for_user(user_id: int):
    async for db in get_db():
        # Функция автоматически обработает всех пользователей с флагом
        result = await send_pending_credentials_emails(db)
        print(f"Отправлено: {result['emails_sent']}")
```

## Часто задаваемые вопросы

**Q: Как часто проверяются отложенные учетные данные?**  
A: При каждом запуске ежедневных задач (обычно раз в день).

**Q: Что происходит, если пользователь никогда не подтвердит email?**  
A: После 10 попыток флаг автоматически снимается. Администратор может передать учетные данные вручную.

**Q: Безопасно ли хранить пароль в открытом виде?**  
A: Пароль хранится временно и только до успешной отправки. После отправки поле очищается. Для дополнительной безопасности можно использовать шифрование.

**Q: Можно ли увеличить лимит попыток?**  
A: Да, измените значение `10` в функции `send_pending_credentials_emails()` в файле `backend/crud.py`.

## Поддержка

При возникновении проблем проверьте:
1. Логи приложения на наличие ошибок
2. Настройки Unisender в `.env`
3. Статус пользователей в базе данных
4. Настройки планировщика задач
